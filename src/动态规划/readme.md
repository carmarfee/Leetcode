# 第一步：定义状态 (Define the State)
这是动态规划的灵魂，也是最重要、最困难的一步。

你需要创建一个数组或矩阵（通常命名为 dp），并明确其中每个元素的含义。即，dp[i] 或 dp[i][j] 到底代表了什么。

技巧：通常从问题所求的目标反推。如果问题求“到 n 的最小代价”，那么 dp[i] 就可以定义为“到 i 的最小代价”。

一维DP：dp[i] 通常表示“当问题规模为 i 时的解”。例如，处理到第 i 个元素时的最优值。

二维DP：dp[i][j] 通常表示“当问题规模与两个变量 i 和 j 相关时的解”。例如，使用前 i 个物品，在背包容量为 j 时的最大价值。

状态定义必须清晰、无歧义，并且能覆盖所有子问题。

# 第二步：找出状态转移方程 (Find the State Transition Equation)
这是动态规划的核心逻辑。

状态转移方程描述了不同状态（子问题）之间的关系。它告诉我们，如何通过已知的、更小子问题的解（比如 dp[i-1]），来计算出当前状态 dp[i] 的解。

技巧：思考**“最后一步”**。要达到 dp[i] 这个状态，上一步可能是从哪个状态转移过来的？把所有可能的上一步情况都考虑到，然后从中选择最优的或者进行加总。

例子：dp[i] = dp[i-1] + dp[i-2] 就是一个著名的状态转移方程。

# 第三步：确定初始条件 (Determine the Base Cases)
这是动态规划的起点，是递推的基石。

状态转移方程定义了如何从子问题推导到大问题，而初始条件（或称“边界条件”）就是那些不需要依赖任何其他状态就能直接确定其值的“最小子问题”。

技巧：通常是 dp 数组的第一个或前几个元素，比如 dp[0]、dp[1] 或者二维 dp 的第一行和第一列。

如果初始条件设置错误，整个递推过程都会出错。

# 第四步：确定计算顺序 (Determine the Order of Computation)
这是代码实现的具体方向。

顺序：观察状态转移方程，dp[i] 依赖于哪些之前的状态？为了保证计算 dp[i] 时，它所依赖的状态都已经被计算出来，我们需要确定正确的遍历顺序。

实现方式：

自底向上 (Bottom-up / Tabulation)：这是最常见的方式。通常通过 for 循环，从初始条件开始，一步步计算，直到得到最终的解。

自顶向下 (Top-down / Memoization)：通过递归函数实现，在递归过程中用一个“备忘录”数组来存储已经计算过的子问题的解，避免重复计算。